#' Stack models according to CRPS
#'
#' @description
#' Provides a wrapper for different EpiSoon models and generates
#' a mixture model of these models based on the (Continuous) Rank Probability
#' Score
#'
#' A list of models is supplied. These models are fit to the data up until a
#' period of observations of size `weighting_period`. Forecasts are generated
#' from all the models for all time points in the `weighting_period`.
#' Predictive samples generated by the individual models are then used to
#' create model weights in an ensemble based on CRPS. All models are then
#' refitted for the entire timeseries and predictions are generated from these
#' models. Draws from the individual model predictive samples are then used
#' to generate a mixture model with the weights obtained in the previous step.
#'
#' The weights are computed using \code{\link[stackr]{stack_crps}} from
#' the package `stackr` to minimise CRPS. The function
#' \code{\link[stackr]{mixture_from_sample}} from the same package is used
#' to draw samples from the
#' individual models to form the mixture models.
#'
#' @param models A list of models. Models must be analogous to the form
#' `function(...){EpiSoon::fable_model(model = , ...)}` or
#' `function(...){EpiSoon::bsts_model(model = , ...)}`.
#' @inheritParams bsts_model
#' @param weighting_period The number of most recent timepoints to hold out to
#' generate the weights for the mixture model
#' @return A dataframe of predictions (with columns representing the
#'  time horizon and rows representing samples).
#' @export
#' @importFrom purrr map_dfr
#' @importFrom dplyr bind_rows n ungroup mutate rename group_by filter
#' @importFrom tidyr pivot_longer pivot_wider
#' @examples
#'
#' \dontrun{
#'
#' # make list with models
#' models <- list(
#'   "ARIMA" = function(...){EpiSoon::fable_model(model = fable::ARIMA(y), ...)},
#'   "ETS" = function(...){EpiSoon::fable_model(model = fable::ETS(y), ...)},
#'   "Drift" = function(...){EpiSoon::fable_model(model = fable::RW(y ~ drift()), ...)}
#' )
#'
#' # make forecst on its own
#' forecast <- stackr_mixture_model(y = EpiSoon::example_obs_rts[1:10, ]$rt
#'                                  models = models,
#'                                  samples = 10,
#'                                  horizon = 7,
#'                                  weighting_period = 5)
#'
#'
#' # together with forecast_rt
#' fc_rt <- forecast_rt(EpiSoon::example_obs_rts[1:10, ],
#'                      model = function(...){
#'                        stackr_mixture_model(models = models,
#'                                             weighting_period = 5,
#'                                             ...)},
#'                      samples = 10,
#'                      horizon = 7)
#'
#' forecast_eval <- evaluate_model(EpiSoon::example_obs_rts,
#'                                 EpiSoon::example_obs_cases,
#'                                 model = function(...){
#'                                   stackr_mixture_model(models = models,
#'                                                        weighting_period = 5,
#'                                                        ...)},
#'                                 horizon = 7, samples = 10,
#'                                 serial_interval = example_serial_interval,
#'                                min_points = 10)
#'
#' plot_forecast_evaluation(forecast_eval$forecast_rts,
#'                          EpiSoon::example_obs_rts,
#'                          horizon_to_plot = 7)
#'
#' }
#'

stackr_mixture_model <- function(y = NULL,
                                 models = NULL,
                                 samples = NULL,
                                 horizon = NULL,
                                 weighting_period = 5) {


  #### Error Handling
  # check if y is there
  if(is.null(y)) stop("parameter y is missing")


  # check if stackr is installed
  check_suggests("stackr",
                 dev_message = "Install using devtools::install_github('nikosbosse/stackr')")

  if (length(y) <= weighting_period) {
    stop("not enough observations to do weighting. Adjust weighting_period")
  }

  #### split data into train data and data for weighting. Use train data to
  # generate forecasts, score them against weight data, then generate forecasts
  # bases on the entire time series and use the obtained weights to create mixture
  n <- length(y)
  y_train <- y[1:(n - weighting_period)]
  y_weight <- y[(n - weighting_period + 1):n]

  #### fit models on train data and generate forecasts
  fc_w <- purrr::map_dfr(seq_along(models),
                         .f = function(i) {
                           model_function <- models[[i]]
                           out <- model_function(y = y_train,
                                                 samples = samples,
                                                 horizon = weighting_period)

                           # bring data in the correct format the stackr package expects
                           dplyr::as_tibble(out) %>%
                             dplyr::mutate(sample_nr = 1:dplyr::n()) %>%
                             tidyr::pivot_longer(names_to = "date",
                                                 values_to = "y_pred",
                                                 cols = -sample_nr) %>%
                             dplyr::group_by(sample_nr) %>%
                             dplyr::mutate(y_obs = y_weight) %>%
                             dplyr::ungroup() %>%
                             dplyr::mutate(model = names(models)[i],
                                           geography = "Testland")

                         })

  # obtain weights based on the training forecasts generated
  w <- stackr::stack_crps(fc_w)

  #### generate real forecasts and use weights to stack
  fc <- purrr::map_dfr(seq_along(models),
                       .f = function(i) {
                         model_function <- models[[i]]
                         out <- model_function(y = y,
                                               samples = samples,
                                               horizon = horizon)

                         # bring data in correct format so the stackr can generate
                         # the mixture
                         as_tibble(out) %>%
                           dplyr::mutate(sample_nr = 1:dplyr::n()) %>%
                           tidyr::pivot_longer(names_to = "date",
                                               values_to = "y_pred",
                                               cols = -sample_nr) %>%
                           dplyr::group_by(sample_nr) %>%
                           dplyr::ungroup() %>%
                           dplyr::mutate(model = names(models)[i],
                                         geography = "Testland")

                       })

  # generate mixture
  mix <- stackr::mixture_from_sample(fc, weights = w)

  # make output compatible with what the other EpiSoon functions return
  mixed_samples <- mix %>%
    dplyr::select(-model, -geography) %>%
    tidyr::pivot_wider(values_from = y_pred, names_from = date) %>%
    dplyr::select(-sample_nr)

  return(mixed_samples)
}


