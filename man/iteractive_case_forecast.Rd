% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterative_case_forecast.R
\name{iteractive_case_forecast}
\alias{iteractive_case_forecast}
\title{Iteratively forecast cases using a iterative Rt forecasts}
\usage{
iteractive_case_forecast(
  it_fit_samples = NULL,
  cases = NULL,
  serial_interval,
  rdist = NULL
)
}
\arguments{
\item{it_fit_samples}{Dataframe of iterative forecasts as produced by \code{iterative_rt_forecast}.}

\item{cases}{A dataframe containing \code{date} and \code{cases} variables}

\item{serial_interval}{A numeric vector describing the probability distribution the serial interval.
See \code{EpiNow::covid_serial_interval} for an example of the format.}

\item{rdist}{A function to be used to sample the number of cases. Must take two
arguments with the first specfying the number of samples and the second the mean. Defaults
to \code{rpois} if not supplied}
}
\value{
A dataframe of iterative case forecasts
}
\description{
Iteratively forecast cases using a iterative Rt forecasts
}
\examples{

cases <- data.frame(cases = 1:20,
                    date = as.Date("2020-01-01") + lubridate::days(1:20))
rts <- data.frame(rt = 1:10,
                 date = as.Date("2020-01-01") + lubridate::days(1:10))


it_forecast <-
  iterative_rt_forecast(rts, model = function(ss, y){bsts::AddSemilocalLinearTrend(ss, y = y)},
                        horizon = 7, samples = 10)

#' ## Example serial interval
mean_si <- 4.7
sd_si <- 2.9

mu_log <- log(mean_si) - 1/2 * log((sd_si / mean_si)^2 + 1)
sd_log <- sqrt(log((sd_si/mean_si)^2 + 1))


serial_interval <- rlnorm(1:100, mu_log, sd_log) \%>\%
   round(0) \%>\%
   table \%>\%
   {. / sum(.)}

iteractive_case_forecast(it_fit_samples = it_forecast, cases = cases,
                         serial_interval = serial_interval)
}
