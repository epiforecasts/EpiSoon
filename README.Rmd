---
output: github_document
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/"
)
```

# EpiSoon

*Warning: This package is a work in progress and is currently developed solely with the COVID-19 outbreak in mind. Breaking changes may occur and the authors cannot guarantee support.*

**Aim:** To forecast the time-varying reproduction number and using this to forecast reported case counts. 

## Installation

Install the analysis and all dependencies with: 

```{r, eval = FALSE}
remotes::install_github("epiforecasts/EpiSoon", dependencies = TRUE)
```


## Quick start


* Load the package (`bsts` for models, `ggplot2` for plotting, and `cowplot` for theming)

```{r, message = FALSE}
library(EpiSoon)
library(bsts)
library(cowplot)
library(dplyr)
```


* Define example observations.

```{r}
obs_rts <- data.frame(rt = 1:20,
                      date = as.Date("2020-01-01")
                      + lubridate::days(1:20))

obs_cases <- data.frame(cases = 5:24, 
                        date = as.Date("2020-01-01")
                        + lubridate::days(1:20))
```

* Forecast a timeseries using a semi-local trend model and  summarise it.

```{r}
samples <- forecast_rt(obs_rts[1:10, ],
                      model = function(ss, y){bsts::AddSemilocalLinearTrend(ss, y = y)},
                      horizon = 7, samples = 10)

 ## Summarise forecast
 summarised_forecast <- summarise_forecast(samples)
 
 summarised_forecast
```

* Score the forecast

```{r}
scores <- score_forecast(samples, obs_rts)

summarise_scores(scores)
```

* Plot the forecast

```{r}
 ## Plot forecast
 plot_forecast(summarised_forecast, obs_rts)
```


* Iteratively fit the forecast and plot this to visualise the forecast quality

```{r} 
forecast_eval <- evaluate_model(obs_rts = obs_rts,
                                obs_cases = obs_cases, 
                                model = function(ss, y){bsts::AddSemilocalLinearTrend(ss, y = y)},
                                horizon = 7, samples = 10)

forecast_rts <- forecast_eval$forecast_rts

 ## Plot forecast
 plot_forecast_evaluation(forecast_rts, obs_rts, horizon_to_plot = c(1, 3, 7)) +
   ggplot2::facet_wrap(~ horizon, ncol = 1) +
   cowplot::panel_border() 
 ## currently still returns warning: "longer object length is not a multiple of shorter object length"
   
```

## Evaluate across models

* Define a list of models.

```{r} 
## List of forecasting bsts models wrapped in functions.
models <- list("Sparse AR" = function(ss, y){bsts::AddAutoAr(ss, y = y, lags = 7)},
                "Semi-local linear trend" = function(ss, y){bsts::AddSemilocalLinearTrend(ss, y = y)})
```

* Compare across models.

```{r}
evaluations <- compare_models(obs_rts = obs_rts, 
                              obs_cases = obs_cases, 
                              models = models, 
                              horizon = 7, samples = 10)
```

* Plot evaluation of models over a set of time horizons.

```{r}
plot_forecast_evaluation(evaluations$forecast_rts, obs_rts, c(1, 3, 7)) +
   ggplot2::facet_grid(model ~ horizon) +
   cowplot::panel_border() 
```

* Score across models

```{r}
summarise_scores(evaluations$rt_scores)
```


### Evaluate across regions and models

* Define multiple timeseries each with multiple samples

```{r} 
obs_rts_ts <- obs_rts %>% 
   dplyr::mutate(timeseries = "Region 1", sample = 1) %>% 
   {dplyr::bind_rows(., dplyr::mutate(., sample = 2))} %>% 
   dplyr::bind_rows(
      obs_rts %>% 
   dplyr::mutate(timeseries = "Region 2", sample = 1) %>% 
   {dplyr::bind_rows(., dplyr::mutate(., sample = 2))}
   )

obs_cases_ts <- obs_cases %>% 
   dplyr::mutate(timeseries = "Region 1") %>% 
   dplyr::bind_rows(
      obs_cases %>% 
   dplyr::mutate(timeseries = "Region 2")
   )


```
* Compare across regions and models

```{r} 
evaluations <- compare_timeseries(obs_rts = obs_rts_ts, 
                                  obs_cases = obs_cases_ts, 
                                  models = models,
                                  horizon = 7, samples = 10)


```


* Plot comparison

```{r}
plot_forecast_evaluation(evaluations$forecast, observations, c(7)) +
   ggplot2::facet_grid(model ~ timeseries) +
   cowplot::panel_border()
```

* Summarise CRPS by region

```{r}
summarise_scores(evaluations$scores, "timeseries", sel_scores = "crps")
```

* Summarise logs by horizon

```{r}
summarise_scores(evaluations$scores, "horizon", sel_scores = "logs")
```

## Docker

This package was developed in a docker container based on the `rocker/geospatial` docker image. 

To build the docker image run (from the `EpiSoon` directory):

```{bash, eval = FALSE}
docker build . -t episoon
```

To run the docker image run:

```{bash, eval = FALSE}
docker run -d -p 8787:8787 --name episoon -e USER=episoon -e PASSWORD=episoon episoon
```

The rstudio client can be found on port :8787 at your local machines ip. The default username:password is epinow:epinow, set the user with -e USER=username, and the password with - e PASSWORD=newpasswordhere. The default is to save the analysis files into the user directory.

To mount a folder (from your current working directory - here assumed to be `tmp`) in the docker container to your local system use the following in the above docker run command (as given mounts the whole `episoon` directory to `tmp`).

```{bash, eval = FALSE}
--mount type=bind,source=$(pwd)/tmp,target=/home/EpiSoon
```

To access the command line run the following:

```{bash, eval = FALSE}
docker exec -ti episoon bash
```
